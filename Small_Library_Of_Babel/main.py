# These are all default libraries to import, because I wish to lower the cost of entry towards this project.
# Some of the logic may appear confusing at times, as well as may be better handled with 3rd party libraries;
# however, less experienced developers may not know how to properly set up and use a venv.
import random

# Repo Imports
from utils import *

"""
UPDATE THESE AND HAVE FUN!
--------------------------
"""
# How many characters you will accept as a valid string. The smaller the number, the smaller the book string will be. Careful not to make it too small
INPUT_SIZE = 100
# Different seeds will impact the random function, and result in different encrypted strings
SEED = 1

# This is the string of valid input options that a user can input (not generated by hand, pulled from below script. The less options, the smaller the book sections will be
VAILD_CHARACTERS = "abcdefghijklmnopqrstuvwxyz0123456789 ."

# This is the string of the valid characters which will become the 'token' for someone to enter and decrypt their sentence
# Work smarter not harder, this string was generated with the following code
# print("".join([chr(index) for index in range(33, 126)]))
# The code above works because
# char(33)  -> !
# char(126) -> }
VALID_ENCRYPTED_CHARACTERS = """!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}"""

"""
ONLY UPDATE IF YOU KNOW WHAT YOU ARE DOING
------------------------------------------
"""
# The string will be chopped off of these characters to allow for an 'interactive' feel with where the string is found
# While you could make this more abstract to be able to be even more scalable, I am already making so much of the configurables dynamic, that I don't want to worry about this
# These need to be in base 2 because the following encryption works as
# 1. Base Valid Characters -> Base 10
# 2. Base 10 -> Base 2
# 3. Chop off the total of bits that the walls, shelves, volumns, pages take up
# 3ex : assuming that all are 2, that is a bit space of 1 meaning a binary string of
# 111001010010 becomes 11100101 0010
# 4. the longer section Base 2 -> Base 10
# 5. Base 10 -> Base Encrypted Characters
# 6. The remaning binary space from step 3 is then interpeted in base 10 value
WALLS = 4
assert power_of_2(WALLS) != None
WALLS_SPACE = power_of_2(WALLS)

SHELVES = 8
assert power_of_2(SHELVES) != None
SHELVES_SPACE = power_of_2(SHELVES)

VOLUMN = 32
assert power_of_2(VOLUMN) != None
VOLUMN_SPACE = power_of_2(VOLUMN)

PAGES = 512
assert power_of_2(PAGES) != None
PAGES_SPACE = power_of_2(PAGES)

# Please dont yell at me for breaking python naming conventions. These are supposed to be static; 
# however, that is no-fun and I would prefer that new users get to enjoy how random seeds effect cryptography
random.seed(SEED)
VAILD_CHARACTERS = list(VAILD_CHARACTERS)
random.shuffle(VAILD_CHARACTERS)
VAILD_CHARACTERS = ''.join(VAILD_CHARACTERS)

VALID_ENCRYPTED_CHARACTERS = list(VALID_ENCRYPTED_CHARACTERS)
random.shuffle(VALID_ENCRYPTED_CHARACTERS)
VALID_ENCRYPTED_CHARACTERS = ''.join(VALID_ENCRYPTED_CHARACTERS)

if __name__ == "__main__":
    print("""\nWelcome to JTexpo's rendition on the library of babel.""")

    while True:

        library_options = get_users_library_option()

        if "1" in library_options:
            # clearing the terminal screen
            print("\n" * 100)

            # get the string that the user wants to encrypt
            user_string = get_user_search_string()

            # running validation on the users input, that way we dont store too big of a page
            groomed_string = groom_user_search_string(user_string, INPUT_SIZE)

            # getting all of the encrypted keys 
            section, wall, shelf, volumn, page = get_book_location(
                groomed_string,
                VAILD_CHARACTERS,
                VALID_ENCRYPTED_CHARACTERS,
                WALLS_SPACE,
                SHELVES_SPACE,
                VOLUMN_SPACE,
                PAGES_SPACE,
            )

            print_book_detail(section, wall, shelf, volumn, page)

        elif "2" in library_options:
            # clearing the terminal screen
            print("\n" * 100)

            section, wall, shelf, volumn, page = get_user_search_location(
                WALLS, SHELVES, VOLUMN, PAGES
            )

            content = get_book_content(
                VAILD_CHARACTERS,
                VALID_ENCRYPTED_CHARACTERS,
                section,
                wall,
                shelf,
                volumn,
                page,
                WALLS_SPACE,
                SHELVES_SPACE,
                VOLUMN_SPACE,
                PAGES_SPACE,
            )

            print(f"\nThat book contains the following content:\n{content}\n")

        elif "0" in library_options:
            break
